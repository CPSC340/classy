import * as fs from "fs-extra";
import * as path from "path";
import { IGradeReport } from "../Types";
import { IContainerOptions } from "../Types";
import FSUtil from "../util/FSUtil";
import Repository from "../util/Repository";
import Container from "./Container";

/**
 * Grades a student's project at a specified commit against a solution key for the assignment.
 */
class Grader {
    private static mntDir: string = `/io`;
    private static reportFilename: string = `report.json`;
    private static transcriptFilename: string = `stdio.txt`;

    public workspace: string;

    private assnDir: string;
    private solnDir: string;
    private keepDir: string;
    private _report: IGradeReport;
    private _isFinished: boolean;

    /**
     * Creates a new grader instance.
     * @param workspace The working directory for the grader.
     */
    constructor(workspace: string) {
        this.workspace = workspace;
        this._isFinished = false;

        this.assnDir = `${this.workspace}/assignment`;
        this.solnDir = `${this.workspace}/solution`;
        this.keepDir = `${this.workspace}/store`;
    }

    /**
     * Returns true once the container has finished executing.
     */
    public get isFinished(): boolean {
        return this._isFinished;
    }

    /**
     * Returns the grade report generated by the container. Value will be undefined unless the grader is finished.
     */
    public get report(): IGradeReport {
        return this._report;
    }

    /**
     * Creates an individual zip for each file in the root of keepDir and stores them at the destination. Directories
     * and nested files are ignored.
     * @param dest The location for the archive. If the destination does not exist, it will be created.
     */
    public async archiveGradingArtifacts(dest: string): Promise<void> {
        const filesToArchive: string[] = await fs.readdir(this.keepDir);
        const zipCopyPromises: Array<Promise<void>> = [];
        for (const file of filesToArchive) {
            zipCopyPromises.push(this.zipTo(file, dest));
        }
        await Promise.all(zipCopyPromises);
    }

    /**
     * Deletes everything in the workspace but does not delete the workspace itself.
     */
    public async clearWorkspace(): Promise<void> {
        fs.remove(this.workspace);
    }

    /**
     * Clones a student's repository to the workspace and checks out the commit to be graded.
     * @param url The url, including credentials, for the student's repository.
     * @param commit The commit to grade.
     */
    public async collectAssignment(url: string, commit: string): Promise<void> {
        const assn: Repository = new Repository(this.assnDir);
        await assn.clone(url);
        return assn.checkout(commit);
    }

    /**
     * Copies the solution repository to the workspace.
     * @param src The source directory containing the solution repository.
     */
    public async copySolution(src: string): Promise<void> {
        // QUESTION does this copy to a sub folder?
        return fs.copy(src, this.solnDir);
    }

    /**
     * Runs the container which performs that actual grading. Retrieves the container stdio and stores it in the keepDir.
     * @param assignmentToGrade The name of the assignment/deliverable.
     * @param timeAlloted The duration, in milliseconds, the container is allowed to run for.
     * @param dockerImageId The image that the container should be started from.
     */
    public async grade(assignmentToGrade: string, timeAlloted: number, dockerImageId: string): Promise<void> {
        const contOptions: IContainerOptions = {
            env: { ASSIGNMENT: assignmentToGrade },
            volumes: [`${this.workspace}:${Grader.mntDir}`],
        };
        const cont: Container = new Container(dockerImageId);
        await fs.mkdirp(this.keepDir);
        await cont.create(contOptions);
        await cont.start(timeAlloted);
        await fs.writeFile(`${this.keepDir}/${Grader.transcriptFilename}`, await cont.getLog());
        this._report = await fs.readJson(`${this.keepDir}/${Grader.reportFilename}`);
        this._isFinished = true;
    }

    /**
     * Checks if the container generated a grade report that conforms to the schema. Useful when debugging containers.
     * @param schema A JSON Schema describing the grade report emitted by the container.
     */
    public isReportValid(schema: object): boolean {
        // TODO
        throw new Error(`Not Implemented`);
    }

    /**
     * Zips a file and stores it at the destination.
     * @param file The path to the file to zip.
     * @param dest The destination directory to store the zip. If the destination does not exist, it will be created.
     */
    private async zipTo(file: string, dest: string): Promise<void> {
        const filename: string = path.basename(file);
        const zipContent: Uint8Array = await FSUtil.zipFile(file);
        return fs.writeFile(`${dest}/${filename}`, zipContent);
    }
}
